# lec 3 SPOC Discussion

## **提前准备**
（请在上课前完成）


 - 完成lec3的视频学习和提交对应的在线练习
 - git pull ucore_os_lab, v9_cpu, os_course_spoc_exercises  　in github repos。这样可以在本机上完成课堂练习。
 - 仔细观察自己使用的计算机的启动过程和linux/ucore操作系统运行后的情况。搜索“80386　开机　启动”
 - 了解控制流，异常控制流，函数调用,中断，异常(故障)，系统调用（陷阱）,切换，用户态（用户模式），内核态（内核模式）等基本概念。思考一下这些基本概念在linux, ucore, v9-cpu中的os*.c中是如何具体体现的。
 - 思考为什么操作系统需要处理中断，异常，系统调用。这些是必须要有的吗？有哪些好处？有哪些不好的地方？
 - 了解在PC机上有啥中断和异常。搜索“80386　中断　异常”
 - 安装好ucore实验环境，能够编译运行lab8的answer
 - 了解Linux和ucore有哪些系统调用。搜索“linux 系统调用", 搜索lab8中的syscall关键字相关内容。在linux下执行命令: ```man syscalls```
 - 会使用linux中的命令:objdump，nm，file, strace，man, 了解这些命令的用途。
 - 了解如何OS是如何实现中断，异常，或系统调用的。会使用v9-cpu的dis,xc, xem命令（包括启动参数），分析v9-cpu中的os0.c, os2.c，了解与异常，中断，系统调用相关的os设计实现。阅读v9-cpu中的cpu.md文档，了解汇编指令的类型和含义等，了解v9-cpu的细节。
 - 在piazza上就lec3学习中不理解问题进行提问。

## 第三讲 启动、中断、异常和系统调用-思考题

## 3.1 BIOS
-  请描述在“计算机组成原理课”上，同学们做的MIPS CPU是从按复位键开始到可以接收按键输入之间的启动过程。
-  x86中BIOS从磁盘读入的第一个扇区是是什么内容？为什么没有直接读入操作系统内核映像？
- 比较UEFI和BIOS的区别。
- 理解rcore中的Berkeley BootLoader (BBL)的功能。

## 3.2 系统启动流程

- x86中分区引导扇区的结束标志是什么？
- x86中在UEFI中的可信启动有什么作用？
- RV中BBL的启动过程大致包括哪些内容？

## 3.3 中断、异常和系统调用比较
- 什么是中断、异常和系统调用？
-  中断、异常和系统调用的处理流程有什么异同？
- 以ucore/rcore lab8的answer为例，ucore的系统调用有哪些？大致的功能分类有哪些？

## 3.4 linux系统调用分析
- 通过分析[lab1_ex0](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab1/lab1-ex0.md)了解Linux应用的系统调用编写和含义。(仅实践，不用回答)
- 通过调试[lab1_ex1](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab1/lab1-ex1.md)了解Linux应用的系统调用执行过程。(仅实践，不用回答)


## 3.5 ucore/rcore系统调用分析 （扩展练习，可选）
-  基于实验八的代码分析ucore的系统调用实现，说明指定系统调用的参数和返回值的传递方式和存放位置信息，以及内核中的系统调用功能实现函数。
- 以ucore/rcore lab8的answer为例，分析ucore 应用的系统调用编写和含义。
- 以ucore/rcore lab8的answer为例，尝试修改并运行ucore OS kernel代码，使其具有类似Linux应用工具`strace`的功能，即能够显示出应用程序发出的系统调用，从而可以分析ucore应用的系统调用执行过程。


## 3.6 请分析函数调用和系统调用的区别
- 系统调用与函数调用的区别是什么？
- 通过分析x86中函数调用规范以及`int`、`iret`、`call`和`ret`的指令准确功能和调用代码，比较x86中函数调用与系统调用的堆栈操作有什么不同？
- 通过分析RV中函数调用规范以及`ecall`、`eret`、`jal`和`jalr`的指令准确功能和调用代码，比较x86中函数调用与系统调用的堆栈操作有什么不同？


## 课堂实践 （在课堂上根据老师安排完成，课后不用做）
### 练习一
通过静态代码分析，举例描述ucore/rcore键盘输入中断的响应过程。

### 练习二
通过静态代码分析，举例描述ucore/rcore系统调用过程，及调用参数和返回值的传递方法。



## 问答题
### 第一节
#### Q1:中断、异常和系统调用有何异同之处？
A:[异]首先，其来源不同。**中断**来源于外设、时钟等生成的与指令执行无关的中断信号，因此它是**异步**的；而**异常**是在执行某一条指令的过程中触发了某些条件，导致不能正常向下执行指令。执行指令过程中产生的错误算是一种异常，如除零、缺页异常等错误；**系统调用**通过一条指令(如 RISC-V 中的 *ecall* , x86 中的 *int 0x80*)主动向下层运行环境请求服务也属于一种异常。在 RISC-V 架构中，中断被称为 Interrupt ，异常被称为 Exception 。 

[同]但是，尽管中断、异常触发的条件有异步、同步之分，它们都可归结为在一条指令执行完毕后， CPU 发现已经触发了中断或异常需要进行处理。此时，CPU 不再区分中断、异常，而是将它们统称为 Trap ，并跳转到一段代码 Trap Handler 进行处理。 

[异]然而，由于中断、异常和系统调用来源不同，处理它们的方法也不一样。Trap Handler 通常仅仅作为一个入口，做的是按照 Trap 来源不同跳转到不同的处理函数的功能。对于中断，我们应跳转到设备对应的驱动程序代码；对于异常，对于一些不可修复的致命错误，我们应杀死发出该意外行为的用户程序，或让整个内核崩溃。有时，对于一些可以修复的错误，我们可以修复错误，并尝试重新执行出了问题的那条指令，如缺页异常；对于系统调用，我们则跳转到系统调用表，并根据系统调用号进而跳转到对应的系统调用代码。

### 第二节
#### Q1:分析在 RISC-V 中断机制中，PLIC 和 CLINT 各起到了什么作用？
A:RISC-V 将所有的中断分为三种，**外部中断 (External Interrupt) 、时钟中断 (Timer Interrupt) 、软件中断 (Software Interrupt) 。**在 CPU 支持同时运行多个硬件线程 (hart) 的情况下，PLIC (Platform-Level Interrupt Controller) 负责处理全局中断，其实就是指外部中断。它会收集所有外设发过来的中断信号，并将其转发给 CPU 中正确的核来进行中断处理；而 CLINT (Core Local Interruptor)负责处理包括时钟中断、软件中断在内的局部中断，可以认为对于每个核都有一个独立的 CLINT 进行局部中断的收集与分发，它们之间不相互影响。
### 第四节
#### Q1:OpenSBI 与 SBI 有何关系？
A:SBI 是一个抽象概念，表示在 RISC-V 架构中，为了 S 态软件(一般指 OS)能够正常运行，它需要与底层运行环境(SEE， Supervisor Execution Environment，由 CPU 和 M 态软件组成)约定一种接口协议，使得它能够正常获取底层运行环境所提供的服务。这种接口协议就称为 SBI 。在[规范](https://github.com/riscv/riscv-sbi-doc/blob/master/riscv-sbi.adoc)中定义了 SBI 需要包含哪些函数和功能。 

而 OpenSBI 是 SBI 所需要底层运行环境 SEE 的一种具体实现，它确实地可以提供 SBI 规定的服务。

#### Q2:高级语言(如 C/C++) 中的函数调用与 RISC-V 中的调用指令有何区别？
A:RISC-V 中的与调用相关的典型指令为 *jal, jalr* ，前者可以将下一条指令的地址保存在 *x1* 寄存器中，并跳转到子函数的入口地址；后者则可以在子函数执行结束后，跳转到 *x1* 寄存器保存的地址，就可以继续执行子函数返回之后的代码。

然而，高级语言中的函数调用，如 c = add(a + b)，仅仅使用上面两条指令是无法描述的。首先，它要向子函数传递参数，也要有位置存放子函数的返回值；其次，在这条语句的执行前后，各通用寄存器的值不能发生变化。因为从这条语句的语义来看，只有变量 c 的值会发生变化。然而，此时另外一些变量的值可能被暂时存在寄存器中，在子函数调用过程中，所在的寄存器很可能会被用到(因为寄存器的数量很少)，从而被修改，意味着这些变量也被修改了，这与这条语句的语义不相符。

为了能够正确的将函数调用的语义翻译成一系列指令，编译器需要遵守所谓的 calling convention ，其中定义了用哪些寄存器进行参数传递与返回值保存，也规定了调用者和被调用者双方各要承担怎样的责任来保证函数调用前后通用寄存器的值不变。事实上，双方各需要将一部分寄存器保存在一块称之为栈的、随着运行不断变化的内存上。RISC-V 中的调用指令，也仅仅是二者任务的一小部分。

#### Q3:如何理解调用规范中的“调用者保存”和“被调用者保存”？
A:调用者保存的寄存器，顾名思义，是由子函数调用者负责保存。保存它们的代码被编译器附加在调用语句前后：即在 *jal* 之前保存在栈上，在子函数返回后从栈上恢复并释放对应的内存。 

被调用者保存的寄存器，由子函数本身负责保存。对应的代码被编译器附加在子函数开始之后和返回之前：分别保存在栈上、从栈上恢复。

#### Q4:同样需要进行上下文环境保存与恢复，你认为函数调用和 Trap 处理有何不同？
A:显然，二者都需要保证过程前后通用寄存器的状态保持不变。但是， Trap 处理常常涉及到特权级的切换，因此，在准备跳转到 Trap Handler 之前，硬件会自动修改一些 CSR 记录 Trap 的各种信息方便 Trap Handler 使用；我们也需要特权级指令 *sret* 来从 Trap 中返回。因此，所涉及到的寄存器更多。 

其次，如果在执行用户程序，从用户态通过 Trap 进入内核态处理，我们还需要将当前使用的栈从用户栈切换到内核栈，不然会在用户栈上留下内核的数据，带来安全隐患。 

另外，我们无法获得编译器的支持，因此只能手写整段汇编代码实现 Trap 的上下文保存与恢复。

#### Q5:RISC-V 是否支持中断嵌套？如果不支持，应怎样做？
A:不支持，因为在准备通过 Trap 进入 S 态时，在  sstatus 寄存器中，硬件会自动将 spie := sie, sie := 0 。从而，在整个 Trap Handler 中，在 S 态的所有中断都会被禁用，因此 RISC-V 原生不支持中断嵌套。

只要在 Trap Handler 中将 sie := 1 即可。然而，必须小心死循环或者死锁。

### 第五节
#### Q1:函数调用和系统调用有何区别？
A:对于应用程序，系统调用提供二进制接口，需要与汇编代码打交道；而标准库将系统调用包装成函数调用，忽略了硬件细节。

## 课后练习

在X86 或在RISC-V CPU模拟器中写一个小程序，在执行除零操作时，提示错误。如果可能，请显示被除数和除数。 

Q1: 在X86-32或64 CPU上在内核态（ring0）写中断设置和服务程序；

Q2: 思考题：在X86-32或64 CPU上在内核态（ring1）写中断设置和服务程序；可能吗？如何写？

Q3: 在RISC-V 32或64 CPU上（M、S）写中断设置和服务程序；

Q4: 思考题：在RISC-V 32或64 CPU上（H、U）写中断设置和服务程序；可能吗？如何写？